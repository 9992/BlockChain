# 추가 예정 사함
- API 사용법 문서 작성하기 
- 포트에 관한 내용을 정리해야함 
- 비 동기화 기술을 추가하면 좋긴하겠지만 무리데스요.


# 실행 순서
1. 블록체인 서버를 킨다.
2. 리액트 뷰 서버를 킨다.
3. 블록체인 서버는 5000포트, 5001포트, 5002포트, 5003포트의 총 4개의 검증자로 구성한다.
4. 블록체인의 서버를 켰으면 한개의 서버에서 데이터를 보낸다는 가정 하에 보낸다.
5. registor_node에 API 호출을 통해 포트를 등록해준다.
6. API CALL 순서는 /contents/genesis_block , /contents/new_contents , /contents/upload/ 순으로 진행한다. 
7. 진행을 할 때 DB는 하나로 진행되기 떄문에, 이점에 유의하여 진행한다.

---

# 체크 항목

구현된 기능중에 가장 긴 체인이 보이면 해당 체인으로 변경되는 함수가 있는데, 이 부분에서 포트번호를 넘겨주고 DB에서 포트번호 칸을 추가하여 해당 포트 번호의 결과만 출력하도록 구현을 해도 좋은 결과값이 나올 수 있을 것 같음


---

# 테스트 케이스

테스트 케이스 실행후 마지막 검증으로 각 노드의 데이터에 블록이 공유가 되었음을 확인하는 POST 명령을 실시

---

# BlockChain
- 사토시 논문 내용 정리
- 블록체인 구현은 Python 3.7 을 사용할 예정
---
# Step 0. 시작

비트코인이 나오게 된 배경은 개인 대 개인의 전자화폐는 금융기관을 거치지 않고 
한 쪽에서 다른 쪽으로 직접 전달되는 온라인 결제를 구현하기 위함이다.

금융 기관에서 제공하는 전자 서명은 부분적인 솔루션을 제공한다. 
이중지불을 막기 위해 신뢰받는 제 3자를 필요로 하기 때문이고 이것이 단점이다.

개인 대 개인 네트워크를 사용해 이중 지불 문제를 해결하는 솔루션을 제안 -> 비트코인

솔루션에 나오는 네트워크는 거래를 해싱해서 타임스탬프를 찍어 해시 기반 작업 증명을 연결한
블록체인(사슬)으로 만들고, 작업증명을 재 수행하지 않고서는 변경할 수 없는 기록을 만드는 것이다.

가장 긴 블록체인(사슬)은 목격된 사건의 순서를 증명할 뿐 아니라 광대한 CPU파워 풀에서 비롯했음을 증명하고, 과반의 CPU파워가 넘어야 블록체인(사슬)을 수정할 수 있다.

이 네트워크 (블록체인 네트워크)는 스스로 최소한의 구조만을 요구하며, 메시지는 최선의 노력을 다해 퍼져나가고, 노드는 자기가 빠진 사이에 벌어진 거래의 증명으로 가장 긴 작업 증명 사슬을 채택함으로 네트워크를 떠났다가 재 합류 가능하다.

---

# Step 1. 서론

인터넷 기반 상거래 -> 전자 결체 -> 처리할 신뢰받는 제 3자 역할 = 금융기관
위의 시스템은 대다수 거래에 충분히 잘 동작함 But 태생적인 약점을 가짐
금융 기관은 분쟁 중재를 피할 수 없기애 완전한 비가역 거래를 할 수 없다.

- 가역적? 바꿀수있다. 비가역적? 바꿀수없다.

비가역 서비스에 맞는 비가역 결제 기능의 상실로 더 큰 비용이 발생하며, 가역성으로 인해 신뢰 결핍이 퍼지게 된다.
상거래자는 많은 정보를 요구하지 않을 경우 더 경계해야만 하며, 사기일 가능성도 불가피 하게 간주된다. 이런 비용과 결제 불확실성은 대면 거래에 물리적 통화를 사용해서 피할 수 있지만 통신 채널을 이용해서 신뢰자 없이 결제할 수 있는 방법은 비트코인 이전에는 없었다.

- 요구사항 : 신뢰를 대신할 암호학적 증명

거래 의사가 있는 두 당사자가 제 3자 없이 서로 직접 거래할 수 있도록 하는 전자 화폐 시스템, 철회는 전산적으로 불가능 해야하며, 사기로부터 판매자를 보호하고, 통상적인 제 3자의 에스크로(예치)방법은 구매자를 보호하기 위해 쉽게 구현될 수 있지만 비트코인에서는 거래 시간 순의 전산적 증명을 생성하는 개인 대 개인간 분산 타임스탬프 서버를 사용한 이중지불 문제의 솔루션을 제안했다. 정직한 노드가 공격자 노드의 협력 그룹보다 총체적으로 더 많은 CPU파워를 통제하는 한 보안상 안전한 시스템 = 비트코인

---

# Step 2. 거래

디지털 서명의 사슬로 전자적 화폐를 정의할 때. 각 소유자는 화폐를 송금할 때 이전 거래 내역 및 다음 소유자의 공개키 해시값을 전자적 서명을 통해 화폐의 끝(블록의 끝)에 첨가한다. 수금자는 소유권의 사슬을 검증할 서명을 검증할 수 있다. 이 과정에서 문제는 수금자가 소유자 가운데 누군가 화폐를 이중지불하지 않았는지 검증할 수 없다는 점. 이에 대한 통상적인 해법은 신뢰받는 중앙통제기관이나 조폐국을 세우고 모든 거래에 점검을 하는 방법이며, 이 방법에서 모든 거래가 끝날 때 마다 조폐국에서는 새로운 화폐로 발행해야 하고, 조폐국에서 직접 발행된 화폐만 이중지불되지 않았다는 신뢰를 받는다. 이 해법을 적용하게 되면 전체통화체계가 은행과 같이 조폐국을 운영하는 회사에 의존하게 된다는 점이 문제다. 따라서 비트코인에서는 이전 소유자가 어떤 거래에도 서명하지 않았음을 수금자에게 알릴 수 있는 수단이 필요로 해서 가장 앞선 거래 하나를 인정하고, 이중지불 시도에 대해서는 신경쓰지 않는다. 이중지불된 거래가 없음을 확인할 수 있는 유일한 방법은 모든 거래를 인식하는 것 뿐. 조폐국 기반 모델에서 조폐국은 모든 거래를 인식했고, 최초로 받은 거래를 결정했을 때. 어떤 신뢰 받는 자도 없이 이 방식을 실현하려먼, 거래는 공개적으로 알려져야하고, 참가자들에게 받은 순서의 단일한 이력에 합의하는 시스템이 필요하다. 수금자는 각 거래의 시점에 그게 최초로 받은 거래임을 노드 다수가 동의했다는 증명을 필요로 한다.

---

# Step 3. 타임스탬프 서버

해법에 대한 시작은 타임스탬프 서버로 시작한다. 타임스탬프가 찍힌 항목 블록의 해시를 가져가 널리 배포하는 식으로 작동을 한다. 타임스탬프는 그 데이터가 명백히 해시에 들어가기 위해 해당 시각부터 존재했음을 증명한다. 각 타임스탬프는 그 해시 안에 이전 타임스탬프 값을 포함하고, 그에 앞선 것들을 하나씩 연장하는 타임스탬프가 찍힌 체인형태를 생성한다.

- 해시의 값은 앞선 해시값과 블록의 값을 해시 연산을 통해 추가로 하는 것 (타임스탬프가 포함된 해시 값임)

---

# Step 4. 작업증명

개인 대 개인 기반으로 분산 타임스탬프 서버를 구현하기 위해 애덤 백의 해시캐시와 유사한 작업증명 시스템을 사용 할 필요가 있었다. 작업증명은 SHA-256과 같은 것을 이용하여 해시 연산을 거친 결과가 0비트 여러 개로 시작할, 특정 값을 찾는 작업을 수반한다. 평균적으로 필요한 연산작업은 결과값에 필요한 0비트 개수에 따라 지수적으로 달라지며 해시 연산을 한 번 실행하는 것으로 검증 가능하다.
비트코인에서는 타임스탬프 네트워크 용으로 블록의 해시에 필요한 0비트를 주는 값이 발견될 때까지 블록 안에 임시값을 증가 하는 것으로 작업 증명을 구현했다. 한 번 작업증명을 충족하는 데 동원됐다면, 그 블록은 해당 작업을 재 수행 하지 않고는 변경될 수 없고, 그 뒤에 이어서 나중에 생성된 블록이 연결되는 만큼 그 블록을 변경하는 재수행 작업은 그 뒤 모든 블록을 연산하는 것을 포함한다.

- 해당 논문에서는 SHA-256을 사용하지만, TEST를 위해 여러가지 해시 알고리즘을 사용해 볼 예정이다.

작업 증명은 다수결의 대표성 문제도 해결, IP주소당 1표에 기반한 다수 조건이면 누구든지 많은 IP를 할당할 수 있고, 이에 의해 장악될 수 있다. 작업 증명은 기본적으로 CPU 당 1표이기 때문에 다수의사는 죄다 작업증명 동작이 투입된 가장 긴 사슬로 대표된다. 다수의 CPU 파워가 정직한 노드에 의해 통제된다면, 가장 정직한 사슬이 가장 빠르게 늘어나 다른 경쟁 사슬을 압도할 것이다. 과거 블록을 변경하려 하면 공격자는 그 블록과 그 뒤를 잇는 모든 블록의 작업증명을 재 수행해야 하고, 그러면서 가장 정직한 노드들의 작업을 따라 앞질러야한다. 시간이 지날수록 노드를 구동하는 하드웨어의 속도 증가, 변화하는 관여도(invest)를 보상하는 난이도(difficulty)를 보상하기 위해 작업 증명 난이도는 시간당 평균 목표치를 조정해 결정되곻, 너무 빨리 생성 되면 난이도를 증가시킨다.

- 악의적인 목적을 가진 공격자가 공격을 성공하기 위해서는 다수 이상을 속일 수 있어야하고 주어진 정보를 바꾸는 것이어야한다.
- IP는 임의로 할당이 가능하지만 CPU는 해당 컴퓨터에서 고유하게 낼수있는 정도가 정해져 있기 떄문에 주어졌다.
- 하드웨어의 속도가 점진적으로 증가하기 때문에, 관여도(?) 에 따라 보상을 해주고, 작업 증명 난이도는 난이도는 변경될 수 있다.

---

# Step 5. 네트워크

## 네트워크 실행 단계
1. 거래는 모든 노드에 브로드캐스트
2. 각 노드는 새로운 거래를 블록에 수집
3. 각 노드가 그 블록에 맞는 난이도에 따라 작업증명 실행
4. 노드가 작업 증명을 찾으면 해당 지점에서 해당 블록을 모두 브로드캐스트 한다.
5. 노드는 모든 거래가 유효하고, 아직 지불되지 않았다는 조건에 맞을 경우에만 그 블록을 승인한다.
6. 노드는 블록 승인을 표현하기 위해 이전 해시로 승인된 블록의 해시를 사용해 체인 안에 다음 블록을 생성한다.

노드는 항상 가장 긴 체인을 정확한 것으로 간주하고 가장 긴 체인에다 붙인다. 두 노드가 동시에 다음블록의 서로 다른 버전(다른 승인을 의미)을 브로드캐스트하게 되면 어떤 노드는 둥 중 하나를 먼저 받을 수 있다. 먼저 받은 것은 내용에 대해 작업을 하긴 하지만 다른 브랜치에도 저장해 다른 내용이 길어질 경우도 대비한다. 이는 다음 작업증명이 발견되면 깨지고 한쪽 브랜치가 더 길어지게 된다. 다른 브랜치를 작업하던 노드는 그 뒤를 이어 그 브랜치로 전환된다.

- 새로운 거래 브로드캐스트가 모든 노드에 도달할 필요는 없다.
- 많은 노드에 도달하는 대로 곧 한 블록에 들어간다. 
- 블록 브로드 캐스트는 메시지 누락에 내성을 갖는다. 만약 블록을 받지 못하면 다음 블록을 받을 때 누락된 것을 알고 요청한다.

---

# Step 6. 인센티브

블록의 첫 거래는 블록을 만든 이에게 인센티브를 준다. 이는 화폐를 중앙기관 없이 노드만으로 돌아가기 위한 수단이며, 인센티브를 주면서 과거 금 채굴자들이 금을 얻기 위해 자원을 쏟는 것 처럼 인센티브를 통해 CPU 파워와 전기를 사용해 자원을 쏟게 하는 것이다. 

- IF 거래의 총 가치 < 투입된 가치 
    - THEN 투입된 가치 - 거래의 총 가치 -> 인센티브로 부여 

### 인센티브는 탐욕적인 공격자를 막은 방법

- 가정) 탐욕적인 공격자가 모든 정직한 노드보다 더 많은 CPU파워를 모을 수 있다.
    - 공격자가 선택할 수 있는 옵션 2가지 
    - 새로운 화폐를 만들어 쓰거나, 자신의 결제를 훔쳐 사람을 속이는 것
    - 두 가지의 옵션 모두 규칙대로 움직여 인센티브를 받는 금액보다 작다. 따라서 규칙대로 움직이게 된다.

---

# Step 7. 디스크 공간 회수

화폐 안의 최종 거래가 충분한 블록에 묻히면 그 전에 지불된 거래는 디스크 공간을 절약하기 위해 폐기됧 수 있다. 블록의 해시를 깨지 않고 이걸 촉진하기 위해 거래는 머클트리로 해시되며, 그 루트만 블록의 해시안에 포함시킨다. 오래된 블록은 트리의 분기를 쳐내서 작게 만들 수 있다. 거래가 없는 블록의 헤더는 약 80바이트* 6 *24*365 => 연간 4.2MB, 2008년부터 통상적으로 판매되는 RAM 2GB짜리 컴퓨터 시스템을 기준으로 연간 1.2GB 단위로 성장하는 무어의 법칙으로 보면 블록의 헤더가 메모리에 보존되어야 한다고 하더라도 저장공간은 문제가 되지 않는다.

---

# Step 8. 간소화한 결제 검증

결제 검증은 전체 네트워크를 구동하지 않고 가능하다. 사용자는 블록의 증명자(논문 상에는 '그'라고 표현됨, 이하 증명자라 표현 하겠음) 가장 긴 작업증명 체인을 가졌다고 확신할 때까지 네트워크 노드를 조회해서 얻을 수 있는 가장 긴 사슬의 블록 헤더 사본을 유지하면서, 해당 거래를 타임스탬프가 찍힌 블록에 연결한 머클 분기를 얻기만 하면 된다. 사용자는 블록의 증명자 거래를 검사할 수는 없지만 사슬 내 장소에 연결함으로써 네트워크 노드가 받아들인 것과 받아들인 이후 확인을 통해 추가된 블록을 볼 수 있다. 

네트워크를 제어하는 노드가 정직한 검증은 믿을만 하지만 네트워크가 공격자에 의해 과점된다면 더 취약해진다. 네트워크 노드가 거래를 자체 검증할 수 있기는 하지만 간소화한 방법은 공격자가 네트워크를 계속 과점할 수 있는 한 그가 조작한 거래에 속을 수 있다. 
- 방지하기 위한 전략
    - 네트워크는 노드가 유효하지 않은 블록을 탐지해 경고를 받을 때 사용자의 소프트웨어가 그 온전한 블록을 내려받게 하고 경고된 거래에 그 모순을 확인하게 하는 것이다.

### 위의 전략은 다소 난해하지만, 블록체인 소프트웨어 구현시 할 수 있는 해결방안에 해당하는 듯하고 내부에 추가 옵션으로 넣어 동작 시킬 수 있을 것 같다.

---

# Step 9. 가치 합치기와 나누기

화폐를 독립적으로 다루는 것은 가능하더라도, 송금에 모든 푼돈을 별도 거래로 만드는 것은 무리한 일이다. 가치를 나누고 합칠 수 있도록 거래는 복수의 입출금을 포함한다. 일반적으로 입금은 먼젓번 거래의 단수 입금 또는 더 작은 양을 결합한 복수 입금이며, 출금은 지불용 출금 하나와 송금인에게 돌려줄 거스름돈 출금하나로 구성된다.
거래가 여러 거래에 의존하고 그 여러 거래가 더 많은 거래에 의존하는 것은 문제가 되지 않는다는 것에 주목해야 한다. 완전 독립된 거래 내역 사본을 추출할 필요는 없다.


### 비트코인의 탄생 목적인 이중지불을 막기 위해 블록에 등록되어야하는 거래내역에 대한 종류이다.
### 입금 : 이전 거래의 입금, 더 작은양을 결합한 복수 입금들
### 출금 : 지불용 출금 하나 , 송금인에게 돌려 줄 거스름돈 출금 하나

---

# Step 10. 프라이버시

전통적인 은행 모델의 경우 신뢰받는 제 3자에게 정보 정급을 제한함으로써 프라이버시를 달성한다.
이는 모든 거래를 공개할 필요성에 따라 배제되지만, 공갴키 익명성을 보존해 다른 장소에서 정보의 흐름을 끊는 걸로 여전히 프라이버시가 보장될 수 있다. 공중은 누군가 다른 누군가에게 보내는 금액을 볼 수 있지만, 거래에 연결된 누군가에 대한 정보는 얻을 수 없다.
증권거래소에서 공개되는 정보 수준과 비슷하게 개별 거래 시각과 규모를 나타내는 것은 공개되지만 그 거래 당사자가 누구인지 알지는 못하는 것과 같은 것이다.

비트코인에서는 신원을 감추고 거래와 공중만을 공개한다. 
부가적인 방책으로 각 거래마다 새로운 키 쌍이 사용돼야 어떤 공통된 소유자에게 연결되는 일을 계속 피할 수 있다. 여러 입금이 동일 소유자의 소유임을 부득이 하게 드러내는 다중입금 거래에서 어떤 연결은 여전히 불가피하다. 그 거래의 키 소유자가 드러나면, 연결이 동일 소유자에게 속한 다른 거래까지 노출할 위험이 있다.

---

# Step 11. 계산

"정리 내용에서는 실제 계산에 대한 내용은 첨부하지 않습니다."

정직한 체인보다 더 빨리 대체 체인을 만들어 내려는 공격자의 시나리오를 고려했을 때, 이 시도가 성공한다 하더라도 그게 아무것도 없는 곳에서 가치를 만들어내거나 공격자가 소유한 적도 없는 돈을 얻게 만드는 식으로 시스템을 무단 변경하게 하는 것을 허용하진 않는다. 노드는 유효하지 않는 거래를 결제로 받아들이지 않으며, 정직한 노드는 그것을 포함하는 블록을 절대 받아들이지 않는다. 공격자는 오로지 자신의 거래에서 그가 최근 지출한 돈을 거둬들이는 것 하나만 바꿀 수 있다.
 
그 외의 내용들은 실제 계산에 관한 부분이어서 생략합니다...

---

# Step 12. 결론

비트코인은 신뢰에 의존하지 않는 전자거래용 시스템이며, 강력한 소유권 통제를 제공하는 디지털 서명으로 만든 화폐라는 프레임 워크로 시작했지만 이중 지불 방지수단이 존재하지 않아 불완전 했고 이를 해결하기 위해 정직한 노드가 CPU 파워 대부분을 통제하면 공격자가 바꾸기는 신속하게 계산적으로 불가능해지는 공개 거래 이력에 작업증명을 사용하는 개인 대 개인 네트워크를 제안했다. 
- 네트워크의 견고함은 그 통일성없는 단순함에 있다.
- 노드는 거의 조정없이 한 번에 모두 동작한다.
- 메시지는 최선의 노력으로 전달만 되면 되기 때문에 식별될 필요가 없다.
- 노드는 마음대로 네트워크를 떠났다가 없는동안 벌어진 일의 증명으로 작업 증명 체인을 받아들여 재 합류 가능하다.
- 유효한 블록을 연장하는 작업과 그걸 승인했음을 나타내고 유효하지 않은 블록에 대한 작업을 거부하는 데 소모하는 자원은 CPU 파워와 전기이며, 이 자원들을 사용하여 결정한다.

---
## 위의 내용들은 필자에 의해 재 해석 되었기 때문에 원본의 내용과 차이가 있을 수 있습니다.
## 출처 : https://bitcoin.org/en/bitcoin-paper
## 작성자 : 또르
---