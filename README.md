# BlockChain
- 사토시 논문 내용 정리
- 블록체인 구현은 Python 3.7 을 사용할 예정
- 그 외의 사항은 추후 수정 예정

# Step 0. 시작

비트코인이 나오게 된 배경은 개인 대 개인의 전자화폐는 금융기관을 거치지 않고 
한 쪽에서 다른 쪽으로 직접 전달되는 온라인 결제를 구현하기 위함이다.

금융 기관에서 제공하는 전자 서명은 부분적인 솔루션을 제공한다. 
이중지불을 막기 위해 신뢰받는 제 3자를 필요로 하기 때문이고 이것이 단점이다.

개인 대 개인 네트워크를 사용해 이중 지불 문제를 해결하는 솔루션을 제안 -> 비트코인

솔루션에 나오는 네트워크는 거래를 해싱해서 타임스탬프를 찍어 해시 기반 작업 증명을 연결한
블록체인(사슬)으로 만들고, 작업증명을 재 수행하지 않고서는 변경할 수 없는 기록을 만드는 것이다.

가장 긴 블록체인(사슬)은 목격된 사건의 순서를 증명할 뿐 아니라 광대한 CPU파워 풀에서 비롯했음을 증명하고, 과반의 CPU파워가 넘어야 블록체인(사슬)을 수정할 수 있다.

이 네트워크 (블록체인 네트워크)는 스스로 최소한의 구조만을 요구하며, 메시지는 최선의 노력을 다해 퍼져나가고, 노드는 자기가 빠진 사이에 벌어진 거래의 증명으로 가장 긴 작업 증명 사슬을 채택함으로 네트워크를 떠났다가 재 합류 가능하다.

# Step 1. 서론

인터넷 기반 상거래 -> 전자 결체 -> 처리할 신뢰받는 제 3자 역할 = 금융기관
위의 시스템은 대다수 거래에 충분히 잘 동작함 But 태생적인 약점을 가짐
금융 기관은 분쟁 중재를 피할 수 없기애 완전한 비가역 거래를 할 수 없다.

- 가역적? 바꿀수있다. 비가역적? 바꿀수없다.

비가역 서비스에 맞는 비가역 결제 기능의 상실로 더 큰 비용이 발생하며, 가역성으로 인해 신뢰 결핍이 퍼지게 된다.
상거래자는 많은 정보를 요구하지 않을 경우 더 경계해야만 하며, 사기일 가능성도 불가피 하게 간주된다. 이런 비용과 결제 불확실성은 대면 거래에 물리적 통화를 사용해서 피할 수 있지만 통신 채널을 이용해서 신뢰자 없이 결제할 수 있는 방법은 비트코인 이전에는 없었다.

- 요구사항 : 신뢰를 대신할 암호학적 증명

거래 의사가 있는 두 당사자가 제 3자 없이 서로 직접 거래할 수 있도록 하는 전자 화폐 시스템, 철회는 전산적으로 불가능 해야하며, 사기로부터 판매자를 보호하고, 통상적인 제 3자의 에스크로(예치)방법은 구매자를 보호하기 위해 쉽게 구현될 수 있지만 비트코인에서는 거래 시간 순의 전산적 증명을 생성하는 개인 대 개인간 분산 타임스탬프 서버를 사용한 이중지불 문제의 솔루션을 제안했다. 정직한 노드가 공격자 노드의 협력 그룹보다 총체적으로 더 많은 CPU파워를 통제하는 한 보안상 안전한 시스템 = 비트코인

# Step 2. 거래

디지털 서명의 사슬로 전자적 화폐를 정의할 때. 각 소유자는 화폐를 송금할 때 이전 거래 내역 및 다음 소유자의 공개키 해시값을 전자적 서명을 통해 화폐의 끝(블록의 끝)에 첨가한다. 수금자는 소유권의 사슬을 검증할 서명을 검증할 수 있다. 이 과정에서 문제는 수금자가 소유자 가운데 누군가 화폐를 이중지불하지 않았는지 검증할 수 없다는 점. 이에 대한 통상적인 해법은 신뢰받는 중앙통제기관이나 조폐국을 세우고 모든 거래에 점검을 하는 방법이며, 이 방법에서 모든 거래가 끝날 때 마다 조폐국에서는 새로운 화폐로 발행해야 하고, 조폐국에서 직접 발행된 화폐만 이중지불되지 않았다는 신뢰를 받는다. 이 해법을 적용하게 되면 전체통화체계가 은행과 같이 조폐국을 운영하는 회사에 의존하게 된다는 점이 문제다. 따라서 비트코인에서는 이전 소유자가 어떤 거래에도 서명하지 않았음을 수금자에게 알릴 수 있는 수단이 필요로 해서 가장 앞선 거래 하나를 인정하고, 이중지불 시도에 대해서는 신경쓰지 않는다. 이중지불된 거래가 없음을 확인할 수 있는 유일한 방법은 모든 거래를 인식하는 것 뿐. 조폐국 기반 모델에서 조폐국은 모든 거래를 인식했고, 최초로 받은 거래를 결정했을 때. 어떤 신뢰 받는 자도 없이 이 방식을 실현하려먼, 거래는 공개적으로 알려져야하고, 참가자들에게 받은 순서의 단일한 이력에 합의하는 시스템이 필요하다. 수금자는 각 거래의 시점에 그게 최초로 받은 거래임을 노드 다수가 동의했다는 증명을 필요로 한다.

# Step 3. 타임스탬프 서버

해법에 대한 시작은 타임스탬프 서버로 시작한다. 타임스탬프가 찍힌 항목 블록의 해시를 가져가 널리 배포하는 식으로 작동을 한다. 타임스탬프는 그 데이터가 명백히 해시에 들어가기 위해 해당 시각부터 존재했음을 증명한다. 각 타임스탬프는 그 해시 안에 이전 타임스탬프 값을 포함하고, 그에 앞선 것들을 하나씩 연장하는 타임스탬프가 찍힌 체인형태를 생성한다.

- 해시의 값은 앞선 해시값과 블록의 값을 해시 연산을 통해 추가로 하는 것 (타임스탬프가 포함된 해시 값임)


# Step 4. 작업증명

개인 대 개인 기반으로 분산 타임스탬프 서버를 구현하기 위해 애덤 백의 해시캐시와 유사한 작업증명 시스템을 사용 할 필요가 있었다. 작업증명은 SHA-256과 같은 것을 이용하여 해시 연산을 거친 결과가 0비트 여러 개로 시작할, 특정 값을 찾는 작업을 수반한다. 평균적으로 필요한 연산작업은 결과값에 필요한 0비트 개수에 따라 지수적으로 달라지며 해시 연산을 한 번 실행하는 것으로 검증 가능하다.
비트코인에서는 타임스탬프 네트워크 용으로 블록의 해시에 필요한 0비트를 주는 값이 발견될 때까지 블록 안에 임시값을 증가 하는 것으로 작업 증명을 구현했다. 한 번 작업증명을 충족하는 데 동원됐다면, 그 블록은 해당 작업을 재 수행 하지 않고는 변경될 수 없고, 그 뒤에 이어서 나중에 생성된 블록이 연결되는 만큼 그 블록을 변경하는 재수행 작업은 그 뒤 모든 블록을 연산하는 것을 포함한다.

- 해당 논문에서는 SHA-256을 사용하지만, TEST를 위해 여러가지 해시 알고리즘을 사용해 볼 예정이다.

작업 증명은 다수결의 대표성 문제도 해결, IP주소당 1표에 기반한 다수 조건이면 누구든지 많은 IP를 할당할 수 있고, 이에 의해 장악될 수 있다. 작업 증명은 기본적으로 CPU 당 1표이기 때문에 다수의사는 죄다 작업증명 동작이 투입된 가장 긴 사슬로 대표된다. 다수의 CPU 파워가 정직한 노드에 의해 통제된다면, 가장 정직한 사슬이 가장 빠르게 늘어나 다른 경쟁 사슬을 압도할 것이다. 과거 블록을 변경하려 하면 공격자는 그 블록과 그 뒤를 잇는 모든 블록의 작업증명을 재 수행해야 하고, 그러면서 가장 정직한 노드들의 작업을 따라 앞질러야한다. 시간이 지날수록 노드를 구동하는 하드웨어의 속도 증가, 변화하는 관여도(invest)를 보상하는 난이도(difficulty)를 보상하기 위해 작업 증명 난이도는 시간당 평균 목표치를 조정해 결정되곻, 너무 빨리 생성 되면 난이도를 증가시킨다.

- 악의적인 목적을 가진 공격자가 공격을 성공하기 위해서는 다수 이상을 속일 수 있어야하고 주어진 정보를 바꾸는 것이어야한다.
- IP는 임의로 할당이 가능하지만 CPU는 해당 컴퓨터에서 고유하게 낼수있는 정도가 정해져 있기 떄문에 주어졌다.
- 하드웨어의 속도가 점진적으로 증가하기 때문에, 관여도(?) 에 따라 보상을 해주고, 작업 증명 난이도는 난이도는 변경될 수 있다.
